{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Welcome to <code>pkgserver</code>, your solution for streamlined KRM package management in conjunction with GitOps systems. <code>Pkgserver</code> is designed to empower operators, developers and/or platform engineers to deploy applications and configurations seamlessly in various environments.</p> <p>With <code>pkgserver</code>, you can embrace continuous delivery practices, ensuring swift and reliable rollouts of changes to your systems. Whether you're managing infrastructure, deploying application in development or production settings, <code>pkgserver</code> provides the tools you need to streamline and automate the deployment process.</p> <p>The <code>pkgserver</code> is tailored to meet the needs of modern infrastructure/application management, offering robust features for managing fleet systems at scale. From orchestrating deployments to tracking changes across your environment, <code>pkgserver</code> aims to simplify the complexities of <code>package</code> management, allowing you to focus on delivering value to your users.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>As the name suggests, the <code>pkgserver</code> manages <code>packages</code>. Fundamentally, a <code>package</code> is a set of Kubernetes Resource Model (KRM) resources in YAML format. These resources may include artifacts of software components, configuration artifacts, or a combination thereof. By leveraging KRM, pkgserver provides a flexible and extensible framework for defining and managing complex software systems, through a well defined API framework.</p> <p>To facilitate the organization of packages, the <code>pkgserver</code> leverages repositories to manage packages. Within this framework, <code>pkgserver</code> distinguishes between two primary types of <code>packages</code>: blueprint packages and deployment packages.</p> <p>Blueprint <code>packages</code>, also known as catalog <code>packages</code>, serve as templates for software components and configurations. These <code>packages</code> define the structure and composition of the desired KRM resources, providing a standardized framework for deployment.</p> <p>On the other hand, deployment <code>packages</code> encapsulate the actual artifacts necessary for deployment, including software components and configuration artifacts. These <code>packages</code> contain the tangible elements required to instantiate the blueprint defined by catalog packages.</p> <pre><code>graph TD;\n    subgraph \"Package Organization\"\n        RepositoryC[Repository Catalog];\n        RepositoryD[Repository Deployment];\n        PackageC[Package Catalog];\n        PackageD[Package Deployment];\n        RepositoryC --&gt; |1:N| PackageC;\n        RepositoryD --&gt; |1:N| PackageD;\n    end</code></pre> <p>Central to the functionality of <code>pkgserver</code> is its robust lifecycle management system for packages. This system encompasses essential operations such as discovery, creation, reading, updating, and deletion of <code>packages</code>, commonly referred to as CRUD operations.</p> <p>Additionally, <code>pkgserver</code> offers comprehensive versioning capabilities, allowing users to track and manage changes to packages over time. This ensures traceability and facilitates the implementation of controlled release processes.</p>"},{"location":"#join-us","title":"Join us","text":"<p>Join us on this journey as we redefine package management and deployment for the next generation of software development and infrastructure/application engineering.</p> <p>Have questions, ideas, bug reports or just want to chat? Come join our discord server.</p>"},{"location":"02-concepts/01_about/","title":"Concepts","text":"<p>As the name suggests, the <code>pkgserver</code> manages <code>packages</code>. Fundamentally, a <code>package</code> is a set of Kubernetes Resource Model (KRM) resources in YAML format. These resources may include artifacts of software components, configuration artifacts, or a combination thereof. By leveraging KRM, pkgserver provides a flexible and extensible framework for defining and managing complex software systems, through a well defined API framework.</p> <p>To facilitate the organization of packages, the <code>pkgserver</code> leverages repositories to manage packages. Within this framework, <code>pkgserver</code> distinguishes between two primary types of <code>packages</code>: blueprint packages and deployment packages.</p> <p>Blueprint <code>packages</code>, also known as catalog <code>packages</code>, serve as templates for software components and configurations. These <code>packages</code> define the structure and composition of the desired KRM resources, providing a standardized framework for deployment.</p> <p>On the other hand, deployment <code>packages</code> encapsulate the actual artifacts necessary for deployment, including software components and configuration artifacts. These <code>packages</code> contain the tangible elements required to instantiate the blueprint defined by catalog packages.</p> <pre><code>graph TD;\n    subgraph \"Package Organization\"\n        RepositoryC[Repository Catalog];\n        RepositoryD[Repository Deployment];\n        PackageC[Package Catalog];\n        PackageD[Package Deployment];\n        RepositoryC --&gt; |1:N| PackageC;\n        RepositoryD --&gt; |1:N| PackageD;\n    end</code></pre> <p>Central to the functionality of <code>pkgserver</code> is its robust lifecycle management system for packages. This system encompasses essential operations such as discovery, creation, reading, updating, and deletion of <code>packages</code>, commonly referred to as CRUD operations.</p> <p>Additionally, <code>pkgserver</code> offers comprehensive versioning capabilities, allowing users to track and manage changes to packages over time. This ensures traceability and facilitates the implementation of controlled release processes.</p>"},{"location":"02-concepts/02_package/","title":"Package","text":"<p>A <code>package</code> represents a collection of KRM resources, organized within a repository and utilizing <code>YAML</code> as the file format. These resources, defined in the Kubernetes Resource Model, encapsulate configurations, definitions, and metadata necessary to deploy and manage specific functionalities or components within a system. Each <code>package</code> is structured to encapsulate related resources, ensuring modularity, portability, and ease of management in various environments. A <code>package</code> is contained within a directory of a repsoitory.</p> <p>Practically a package can be used in various ways (e.g. a certManager package would be a package to ), Configuration artifacts</p>"},{"location":"02-concepts/02_package/#packagerevision","title":"PackageRevision","text":"<p>A <code>package</code> in the <code>pkgserver</code> is represented through a <code>PackageRevision</code> resource in the Kubernetes API server. </p>"},{"location":"02-concepts/02_package/#identification","title":"Identification","text":"<p>A <code>PackageRevision</code> is uniquely identified by the following parameters:</p> <p>Target: Specifies the deployment target where the package will be deployed.</p> <p>Repository: Indicates the repository hosting the package.</p> <p>Realm: Represents a logical grouping or domain name that associates related packages together.</p> <p>Package: Denotes the name of the package.</p> <p>Workspace: Specifies the working environment or branch where the package is being edited.</p> <p>Revision: Signifies a unique identifier for a specific revision of the package. This parameter becomes relevant once the package is published.</p>"},{"location":"02-concepts/02_package/#lifecycle","title":"Lifecycle","text":"<p>A <code>PackageRevision</code> defines the revision of a package and is managed through a state machine. A <code>PackageRevision</code> can exist in the following states within the state machine:</p> <p>Draft: The initial state of a package revision. In this state, the <code>package revision</code> is actively being developed and is not yet ready for publication.     When using a Git Repository, the <code>package</code> is contained within a specific workspace branch representing the package revision.</p> <p>Proposed: Transitioning from the Draft state, a <code>package revision</code> enters the Proposed state when it is submitted for review and consideration for publication. This is an administrative action without influence on the revision backend.</p> <p>Published: Once approved, a <code>package revision</code> moves into the Published state, indicating that it is publicly available for consumption. At this stage, the <code>package</code> receives a specific <code>package revision</code> identifier that uniquely identifies the package.     When using a Git Repository, the package is merged into the main branch and tagged with a specific <code>package revision</code> tag that uniquely identifies the package.</p> <p>Deletion Proposed: In certain circumstances, a <code>package revision</code> may be marked for deletion. It enters the Deletion Proposed state pending approval for removal. This is an administrative action without influence on the revision backend.</p> <p>Deleted: The final state of a <code>package revision</code>, indicating that it has been removed from the system and is no longer accessible. If a <code>package revisio</code>n ever had a <code>package revision</code> identifier, the tag will be deleted when it transitions to the Deleted state.</p> <pre><code>graph TD;\n    subgraph \"Package Lifecycle\"\n        Deleted;\n        DeletionProposed;\n        Published;\n        Draft;\n        Proposed;\n        Deleted -- Create (Create Branch) --&gt; Draft;\n        DeletionProposed -- Delete (Delete Tag) --&gt; Deleted;\n        DeletionProposed -- Update (Lifecycle: Publish) --&gt; Published;\n        Draft -- Delete --&gt; Deleted;\n        Draft -- Update (Lifecycle: Draft) --&gt; DeletionProposed;\n        Draft -- Update (Lifecycle: Proposed) --&gt; Proposed;\n        Proposed -- Delete --&gt; Deleted;\n        Proposed -- Update (Lifecycle: Draft) --&gt; Draft;\n        Proposed -- Update (Lifecycle: Publish) (Create TAG, merge WS branch to main)--&gt; Published;\n        Proposed -- Update (Lifecycle: Deletion proposed) --&gt; DeletionProposed;\n        Published -- Update (Lifecycle: Deletion proposed) --&gt; DeletionProposed;\n    end</code></pre>"},{"location":"03-userguide/01_about/","title":"UserGuide","text":"<p>The <code>PkgServer</code> is system that handles the lifecycle of a <code>Package</code></p> <p>It provides a control plane for creating, modifying, updating, and deleting packages, and evaluating functions on package data. This enables operations on packaged resources similar to operations directly on the live state through the Kubernetes API.</p>"},{"location":"03-userguide/01_about/#the-kform-configuration-language","title":"The KForm configuration language","text":""},{"location":"03-userguide/02_repository/","title":"Repository","text":""},{"location":"03-userguide/03_package/","title":"Repository","text":""},{"location":"03-userguide/10_api/","title":"Repository","text":""},{"location":"04-examples/01_about/","title":"Examples","text":""},{"location":"05-dev/01_about/","title":"Development guide","text":""},{"location":"07-community/01_about/","title":"Community","text":""}]}